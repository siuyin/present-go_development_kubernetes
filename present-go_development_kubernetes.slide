Go development for Kubernetes
From code to deployment
9 Jan 2020

Loh Siu Yin
Technology Consultant, Beyond Broadcast LLP
siuyin@beyondbroadcast.com



* From code to deployment

- Write code: Go 
- Test: unit tests
- Containerize: Dockerfile
- Deploy (Test [fuctional, integration, end-to-end]: Skaffold
- Deploy: Staging, Production, Metrics, Logging



* Writing Go code

First outline what you want to build, define system level components.

  Go Hello World web app
  NATS Streaming provides internal messaging and stores state
  
  Deployed on Kubernetes

Then define Go app's major modules.

  Web request routing: main.go
  Web request handlers: / -> time service (time.go)

Setup go development environment:

.link https://golang.org/dl/

  > go version
  go version go1.13.4 linux/amd64



* Initialise go module

  > go mod init github.com/siuyin/present-go_development_kubernetes
  go: creating new go.mod: module github.com/siuyin/present-go_development_kubernetes

The above command creates a go.mod file.
This file tells Go that this folder hosts a set of Go packages that can be found at https://github.com/siuyin/present-go_development_kubernetes .

  > cat go.mod
  module github.com/siuyin/present-go_development_kubernetes
  
  go 1.13



* Write main.go

My convention is to put executable commands in a cmd folder:

  > mkdir -p cmd/hello_app/

cmd/hello_app/main.go:

  package main
  
  import "fmt"
  
  func main() {
          fmt.Println("hello_app")
  }

build and run:

  > go run cmd/hello_app/main.go
  hello_app




* main.go: add http server

cmd/hello_app/main.go:

  ...
  
  func main() {
          fmt.Println("hello_app")
          http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
                  fmt.Fprintf(w, "Hello World!\n")
          })
          log.Fatal(http.ListenAndServe(":8080", nil))
  }

test:

  > go run cmd/hello_app/main.go

In a separate terminal:

  > curl localhost:8080/
  Hello World!



* Time service

Create a folder to hold _our_ time module.

  mkdir time

time/time.go (first attempt)

  package time
  
  import gt "time" // go standard library time package, imported as gt
  
  func Now() string {
  	return gt.Now().Format("15:04:05")
  }

But this poses a testing problem -- it returns a new time each time it is tested!
One way around this issue is to define what is "now" and subtitute a fixed time during testing.



* Time service with testability

.code time/time.go




* Time service test

.code time/time_test.go /10 OMIT/,/20 OMIT/

* Time service example and unit test run

.code time/time_test.go /20 OMIT/,/30 OMIT/

Unit test run:

  > go test time/*.go -v
  === RUN   TestNow
  --- PASS: TestNow (0.00s)
  === RUN   ExampleNow
  --- PASS: ExampleNow (0.00s)
  PASS
  ok      command-line-arguments  0.002s




* Main function

.code cmd/hello_app/main.go /20 OMIT/,/30 OMIT/

webServer and heartBeat are independently executing goroutines.
I prefer this style which I call the "Hakka Roundhouse" monolith.

My preferred way of communication between these internal "processes" is with NATS Streaming or NATS.

Communication with external systems can be through http / json or gRPC.



* webServer

.code cmd/hello_app/main.go /10 OMIT/,/20 OMIT/
.code cmd/hello_app/main.go /30 OMIT/,/40 OMIT/



* heartBeat

.code cmd/hello_app/main.go /10 OMIT/,/20 OMIT/
.code cmd/hello_app/main.go /40 OMIT/,/50 OMIT/




* Go modules and external dependencies

"github.com/siuyin/dflt" is an external dependency.

When go test, go run or any other "go" command is run:

- go.mod is updated to include the external dependency

  > cat go.mod
  module github.com/siuyin/present-go_development_kubernetes
  
  go 1.13

  require github.com/siuyin/dflt v0.0.0-20190616123008-ea16caf9b8ef

- go.sum, a checksum file, is created. go.sum should be added to git or your software repository.




* Docker

Download and run docker daemon:

.link https://docs.docker.com/install/

  > docker version
  Client: Docker Engine - Community
   Version:           19.03.5
   API version:       1.40
   Go version:        go1.12.12
   Git commit:        633a0ea838
   Built:             Wed Nov 13 07:29:52 2019
   OS/Arch:           linux/amd64
   Experimental:      false
  
  Server: Docker Engine - Community
   Engine:
    Version:          19.03.5
    API version:      1.40 (minimum version 1.12)
    Go version:       go1.12.12
    Git commit:       633a0ea838
    Built:            Wed Nov 13 07:28:22 2019
    OS/Arch:          linux/amd64
    Experimental:     false
   containerd:
    Version:          1.2.10
    GitCommit:        b34a5c8af56e510852c35414db4c1f4fa6172339
   runc:
    Version:          1.0.0-rc8+dev
    GitCommit:        3e425f80a8c931f88e6d94a8c831b9d5aa481657
   docker-init:
    Version:          0.18.0
    GitCommit:        fec3683




* Containerizing

Create a .dockerignore:

.code .dockerignore

Create a dockerfile:

.code dockerfile



* Dockerfile notes
This is a two stage build:

- Stage 1 uses the Go Alpine image to build. Apline is a smaller image good for pure-go compiles. For cgo (glibc) use the regular golang:1.13 image.
- Stage 2 deploys the result of the build into an empty (scratch) image.  

"go mod download" allows caching of the downloaded modules in the image being built:

- To be effective source code changes reflected in "COPY . ." must be after "go mod download".

* Create and tag an image

The image created below is siuyin/junk with a default tag of "latest".

  docker build . -t siuyin/junk


We can provide a "v1" tag thus:

  docker build . -t siuyin/junk:v1

To list images under siuyin/junk:

  > docker images siuyin/junk
  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
  siuyin/junk         latest              d3100abc3851        47 minutes ago      7.4MB
  siuyin/junk         v1                  d3100abc3851        47 minutes ago      7.4MB




* Create a container and run it

  docker run -it --rm -p 9090:8080 siuyin/junk 
    or
  docker run -it --rm -p 9090:8080 siuyin/junk:v1

Notes:
-it : i for interactive and t for "allocate TTY (terminal)".
--rm :  to remove the container after it exits.
-p : connect (tcp) port 9090 on host running docker daemon to port 8080 of the code running inside the container.
siuyin/junk : name of the image used create the container. If tag is not specified "latest" is used.

---

On host running docker daemon:

  > curl 127.0.0.1:9090
  Hello, the time is 02:44:07




* Presentation and code download

.link https://github.com/siuyin/present-go_development_kubernetes

