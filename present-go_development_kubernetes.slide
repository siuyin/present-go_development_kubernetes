Go development for Kubernetes
From code to deployment
9 Jan 2020

Loh Siu Yin
Technology Consultant, Beyond Broadcast LLP
siuyin@beyondbroadcast.com



* From code to deployment

- Write code: Go 
- Test: unit tests
- Containerize: Dockerfile
- Deploy (Test [functional, integration, end-to-end]: Skaffold
- Deploy: Staging, Production, Metrics, Logging




* Writing Go code

First outline what you want to build, define system level components.

  Go Hello World web app
  NATS Streaming provides internal messaging and stores state
  
  Deployed on Kubernetes

Then define Go app's major modules.

  Web request routing: main.go
  Web request handlers: / -> time service (time.go)



* Set up go development environment:

.link https://golang.org/dl/

  > go version
  go version go1.13.4 linux/amd64



* Initialise go module

  > go mod init github.com/siuyin/present-go_development_kubernetes
  go: creating new go.mod: module github.com/siuyin/present-go_development_kubernetes

The above command creates a go.mod file.
This file tells Go that this folder hosts a set of Go packages that can be found at https://github.com/siuyin/present-go_development_kubernetes .

  > cat go.mod
  module github.com/siuyin/present-go_development_kubernetes
  
  go 1.13



* Write main.go

My convention is to put executable commands in a cmd folder:

  > mkdir -p cmd/hello_app/

cmd/hello_app/main.go:

  package main
  
  import "fmt"
  
  func main() {
          fmt.Println("hello_app")
  }

build and run:

  > go run cmd/hello_app/main.go
  hello_app




* main.go: add http server

cmd/hello_app/main.go:

  ...
  
  func main() {
          fmt.Println("hello_app")
          http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
                  fmt.Fprintf(w, "Hello World!\n")
          })
          log.Fatal(http.ListenAndServe(":8080", nil))
  }

test:

  > go run cmd/hello_app/main.go

In a separate terminal:

  > curl localhost:8080/
  Hello World!



* Time service

Create a folder to hold _our_ time module.

  mkdir time

time/time.go (first attempt)

  package time
  
  import gt "time" // go standard library time package, imported as gt
  
  func Now() string {
  	return gt.Now().Format("15:04:05")
  }

But this poses a testing problem -- it returns a new time each time it is tested!
One way around this issue is to define what is "now" and subtitute a fixed time during testing.



* Time service with testability

.code time/time.go




* Time service test

.code time/time_test.go /10 OMIT/,/20 OMIT/



* Time service example and unit test run

.code time/time_test.go /20 OMIT/,/30 OMIT/

Unit test run:

  > go test time/*.go -v
  === RUN   TestNow
  --- PASS: TestNow (0.00s)
  === RUN   ExampleNow
  --- PASS: ExampleNow (0.00s)
  PASS
  ok      command-line-arguments  0.002s




* Main function

.code cmd/hello_app/main.go /20 OMIT/,/30 OMIT/

webServer and heartBeat are independently executing goroutines.
I prefer this style which I call the "Hakka Roundhouse" monolith.

My preferred way of communication between these internal "processes" is with NATS Streaming or NATS.

Communication with external systems can be through http / json or gRPC.



* webServer

.code cmd/hello_app/main.go /10 OMIT/,/20 OMIT/
.code cmd/hello_app/main.go /30 OMIT/,/40 OMIT/



* heartBeat

.code cmd/hello_app/main.go /10 OMIT/,/20 OMIT/
.code cmd/hello_app/main.go /40 OMIT/,/50 OMIT/



* Go modules and external dependencies

"github.com/siuyin/dflt" is an external dependency.

When go test, go run or any other "go" command is run:

- go.mod is updated to include the external dependency

  > cat go.mod
  module github.com/siuyin/present-go_development_kubernetes
  
  go 1.13

  require github.com/siuyin/dflt v0.0.0-20190616123008-ea16caf9b8ef

- go.sum, a checksum file, is created. go.sum should be added to git or your software repository.




* Docker

Download and run docker daemon:

.link https://docs.docker.com/install/

  > docker version
  Client: Docker Engine - Community
   Version:           19.03.5
   API version:       1.40
   Go version:        go1.12.12
   Git commit:        633a0ea838
   Built:             Wed Nov 13 07:29:52 2019
   OS/Arch:           linux/amd64
   Experimental:      false
  
  Server: Docker Engine - Community
   Engine:
    Version:          19.03.5
    API version:      1.40 (minimum version 1.12)
    Go version:       go1.12.12
    Git commit:       633a0ea838
    Built:            Wed Nov 13 07:28:22 2019
    OS/Arch:          linux/amd64
    Experimental:     false
   containerd:
    Version:          1.2.10
    GitCommit:        b34a5c8af56e510852c35414db4c1f4fa6172339
   runc:
    Version:          1.0.0-rc8+dev
    GitCommit:        3e425f80a8c931f88e6d94a8c831b9d5aa481657
   docker-init:
    Version:          0.18.0
    GitCommit:        fec3683




* Containerizing

Create a .dockerignore:

.code .dockerignore

Create a Dockerfile:

.code Dockerfile



* Dockerfile notes
This is a two stage build:

- Stage 1 uses the Go Alpine image to build. Apline is a smaller image good for pure-go compiles. For cgo (glibc) use the regular golang:1.13 image.
- Stage 2 deploys the result of the build into an empty (scratch) image.  

"go mod download" allows caching of the downloaded modules in the image being built:

- To be effective source code changes reflected in "COPY . ." must be after "go mod download".



* Create and tag an image

The image created below is siuyin/junk with a default tag of "latest".

  docker build . -t siuyin/junk


We can provide a "v1" tag thus:

  docker build . -t siuyin/junk:v1

To list images under siuyin/junk:

  > docker images siuyin/junk
  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
  siuyin/junk         latest              d3100abc3851        47 minutes ago      7.4MB
  siuyin/junk         v1                  d3100abc3851        47 minutes ago      7.4MB




* Create a container and run it

  docker run -it --rm -p 9090:8080 siuyin/junk 
    or
  docker run -it --rm -p 9090:8080 siuyin/junk:v1

Notes:
-it : i for interactive and t for "allocate TTY (terminal)".
--rm :  to remove the container after it exits.
-p : connect (tcp) port 9090 on host running docker daemon to port 8080 of the code running inside the container.
siuyin/junk : name of the image used create the container. If tag is not specified "latest" is used.

---

On host running docker daemon:

  > curl 127.0.0.1:9090
  Hello, the time is 02:44:07

* Kubernetes

Launch development kubernetes 'cluster' with minikube.

check:

  > kubectl get no
  NAME       STATUS   ROLES    AGE    VERSION
  minikube   Ready    master   5d3h   v1.17.0
  
  > kubectl cluster-info
  Kubernetes master is running at https://192.168.39.230:8443
  KubeDNS is running at https://192.168.39.230:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

* Create a kubernetes deployment

base/deployment.yaml:

  metadata:
    name: hello-app
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: hello-app
    template:
      metadata:
        labels:
          app: hello-app
      spec:
        terminationGracePeriodSeconds: 5
        containers:
        - name: hello-app
          image: siuyin/junk:v1

* Deployment notes

spec/replicas: 1 <-- deploy one replica

spec/selector/matchLabels: app: hello-app <-- manage pods with label app=hello-app

spec/template/metadata/labels: app: hello-app <-- when creating pods give them a label app=hello-app

spec/template/spec/containers[0]/image: siuyin/junk:v1 <-- use this image when creating a pod

---

metadata/name: hello-app <-- name this deployment hello-app
spec/template/spec/containers[0]/name: hello-app <-- name pods created by deployment hello-app


* Deploying hello-app deployment

  > kubectl apply -f base/deployment.yaml
  deployment.apps/hello-app created

  > kubectl get deploy
  NAME                READY   UP-TO-DATE   AVAILABLE   AGE
  hello-app           1/1     1            1           3m38s

  > kubectl get po -l app=hello-app
  NAME                         READY   STATUS    RESTARTS   AGE
  hello-app-7cb499bc66-dxkjm   1/1     Running   0          5m1s

Notes:

deploy is short for deployment
po is short for pod
-l app=hello-app <-- select pods with labels matching app=hello-app

* Deploying NATS Streaming

base/nats-streaming-deployment.yaml:

  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nats-streaming
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nats-streaming
    template:
      metadata:
        labels:
          app: nats-streaming
      spec:
        terminationGracePeriodSeconds: 5
        containers:
        - name: nats-streaming
          image: nats-streaming:0.16.2

* Check NATS Streaming

  > kubectl apply -f base/nats-streaming-deployment.yaml 
  deployment.apps/nats-streaming created

  > kubectl get po -l app=nats-streaming
  NAME                              READY   STATUS    RESTARTS   AGE
  nats-streaming-76599cdffc-hknn9   1/1     Running   0          110s

At this stage, both hello-app and nats-streaming are running in kubernetes.

However neither are  accessible from within or outside the cluster. We need services.

* hello-app service

base/service.yaml:

.code base/service.yaml

* hello-app service notes:
metadata/name: hello-app <-- this service is named hello-app

spec/selector: app: hello-app <-- this service connects to pods with labels app=hello-app

spec/ports[0]/port: 8080 <-- connect to this service via port 8080

spec/ports[0]/targetPort: 8080 <-- connects to port 8080 on backend pods.

spec/type: NodePort <-- exposes this service on all nodes of the kubernetes cluster

spec/type can also be ClusterIP which is the default type. ClusterIP services are accessible only within the cluster.

Service names (metadata/name) are registered internally with kubernetes DNS and can thus be reached by name.

  eg. from a pod running in kubernetes
  > curl hello-app:8080/

* Accessing hello-app from outside the cluster.

As hello-app service is a NodePort it can be reached from outside the cluter.

  > kubectl cluster-info
  Kubernetes master is running at https://192.168.39.230:8443

  > kubectl get svc | grep hello-app
  hello-app                   NodePort    10.96.30.244    <none>        8080:32449/TCP                15m

  > curl 192.168.39.230:32449/
  Hello, the time is 07:13:09

* Presentation and code download


.link https://github.com/siuyin/present-go_development_kubernetes

